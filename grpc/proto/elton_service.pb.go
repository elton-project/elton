// Code generated by protoc-gen-go.
// source: elton_service.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	elton_service.proto

It has these top-level messages:
	ObjectName
	ObjectInfo
	Object
	ResponseType
*/
package proto

import proto1 "github.com/golang/protobuf/proto"

// discarding unused import google_api1 "google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal

type ObjectName struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *ObjectName) Reset()         { *m = ObjectName{} }
func (m *ObjectName) String() string { return proto1.CompactTextString(m) }
func (*ObjectName) ProtoMessage()    {}

type ObjectInfo struct {
	ObjectId        string `protobuf:"bytes,1,opt,name=object_id" json:"object_id,omitempty"`
	Version         uint64 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	Delegate        string `protobuf:"bytes,3,opt,name=delegate" json:"delegate,omitempty"`
	RequestHostname string `protobuf:"bytes,4,opt,name=request_hostname" json:"request_hostname,omitempty"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto1.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}

type Object struct {
	Body string `protobuf:"bytes,1,opt,name=body" json:"body,omitempty"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto1.CompactTextString(m) }
func (*Object) ProtoMessage()    {}

type ResponseType struct {
}

func (m *ResponseType) Reset()         { *m = ResponseType{} }
func (m *ResponseType) String() string { return proto1.CompactTextString(m) }
func (*ResponseType) ProtoMessage()    {}

func init() {
}

// Client API for EltonService service

type EltonServiceClient interface {
	GenerateObjectID(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (EltonService_GenerateObjectIDClient, error)
	CreateObjectInfo(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (EltonService_CreateObjectInfoClient, error)
	GetObject(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (EltonService_GetObjectClient, error)
	DeleteObject(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (*ResponseType, error)
}

type eltonServiceClient struct {
	cc *grpc.ClientConn
}

func NewEltonServiceClient(cc *grpc.ClientConn) EltonServiceClient {
	return &eltonServiceClient{cc}
}

func (c *eltonServiceClient) GenerateObjectID(ctx context.Context, in *ObjectName, opts ...grpc.CallOption) (EltonService_GenerateObjectIDClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EltonService_serviceDesc.Streams[0], c.cc, "/proto.EltonService/GenerateObjectID", opts...)
	if err != nil {
		return nil, err
	}
	x := &eltonServiceGenerateObjectIDClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EltonService_GenerateObjectIDClient interface {
	Recv() (*ObjectInfo, error)
	grpc.ClientStream
}

type eltonServiceGenerateObjectIDClient struct {
	grpc.ClientStream
}

func (x *eltonServiceGenerateObjectIDClient) Recv() (*ObjectInfo, error) {
	m := new(ObjectInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eltonServiceClient) CreateObjectInfo(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (EltonService_CreateObjectInfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EltonService_serviceDesc.Streams[1], c.cc, "/proto.EltonService/CreateObjectInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &eltonServiceCreateObjectInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EltonService_CreateObjectInfoClient interface {
	Recv() (*ObjectInfo, error)
	grpc.ClientStream
}

type eltonServiceCreateObjectInfoClient struct {
	grpc.ClientStream
}

func (x *eltonServiceCreateObjectInfoClient) Recv() (*ObjectInfo, error) {
	m := new(ObjectInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eltonServiceClient) GetObject(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (EltonService_GetObjectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EltonService_serviceDesc.Streams[2], c.cc, "/proto.EltonService/GetObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &eltonServiceGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EltonService_GetObjectClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type eltonServiceGetObjectClient struct {
	grpc.ClientStream
}

func (x *eltonServiceGetObjectClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eltonServiceClient) DeleteObject(ctx context.Context, in *ObjectInfo, opts ...grpc.CallOption) (*ResponseType, error) {
	out := new(ResponseType)
	err := grpc.Invoke(ctx, "/proto.EltonService/DeleteObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EltonService service

type EltonServiceServer interface {
	GenerateObjectID(*ObjectName, EltonService_GenerateObjectIDServer) error
	CreateObjectInfo(*ObjectInfo, EltonService_CreateObjectInfoServer) error
	GetObject(*ObjectInfo, EltonService_GetObjectServer) error
	DeleteObject(context.Context, *ObjectInfo) (*ResponseType, error)
}

func RegisterEltonServiceServer(s *grpc.Server, srv EltonServiceServer) {
	s.RegisterService(&_EltonService_serviceDesc, srv)
}

func _EltonService_GenerateObjectID_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObjectName)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EltonServiceServer).GenerateObjectID(m, &eltonServiceGenerateObjectIDServer{stream})
}

type EltonService_GenerateObjectIDServer interface {
	Send(*ObjectInfo) error
	grpc.ServerStream
}

type eltonServiceGenerateObjectIDServer struct {
	grpc.ServerStream
}

func (x *eltonServiceGenerateObjectIDServer) Send(m *ObjectInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _EltonService_CreateObjectInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObjectInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EltonServiceServer).CreateObjectInfo(m, &eltonServiceCreateObjectInfoServer{stream})
}

type EltonService_CreateObjectInfoServer interface {
	Send(*ObjectInfo) error
	grpc.ServerStream
}

type eltonServiceCreateObjectInfoServer struct {
	grpc.ServerStream
}

func (x *eltonServiceCreateObjectInfoServer) Send(m *ObjectInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _EltonService_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObjectInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EltonServiceServer).GetObject(m, &eltonServiceGetObjectServer{stream})
}

type EltonService_GetObjectServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type eltonServiceGetObjectServer struct {
	grpc.ServerStream
}

func (x *eltonServiceGetObjectServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func _EltonService_DeleteObject_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ObjectInfo)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(EltonServiceServer).DeleteObject(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _EltonService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.EltonService",
	HandlerType: (*EltonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteObject",
			Handler:    _EltonService_DeleteObject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GenerateObjectID",
			Handler:       _EltonService_GenerateObjectID_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateObjectInfo",
			Handler:       _EltonService_CreateObjectInfo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetObject",
			Handler:       _EltonService_GetObject_Handler,
			ServerStreams: true,
		},
	},
}
